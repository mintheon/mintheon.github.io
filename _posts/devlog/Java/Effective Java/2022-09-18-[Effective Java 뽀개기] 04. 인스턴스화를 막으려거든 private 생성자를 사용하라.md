---
layout: post
title: '[Effective Java 뽀개기] 04. 인스턴스화를 막으려거든 private 생성자를 사용하라'
subtitle: 'java'
date: 2022-09-28 23:52:48
categories: devlog
tags: java study
---

![image-20220904212556629](https://tva1.sinaimg.cn/large/e6c9d24egy1h5uufg0s7hj21do0ks0w4.jpg)

가끔 **정적 메서드와 정적 필드만을 담은 클래스를 만들고 싶을 때가 있을 것**이다.

하지만 다음과 같은 나름의 쓰임새가 있다.

1. 안티패턴이지만 유사한 그룹으로 묶인 유틸성 로직들을 모아놓을 수 있다.
   1. (ex) java.util.Arrays, java.util.Collections
2. final 클래스와 관련한 메서드들을 모아놓을 때 사용한다.

하지만 이런 **유틸리티성 클래스는 인스턴스로 만들어 쓸 이유가 없으나, 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어준다. 하지만 사용자는 해당 부분을 알 수 없기 때문에 의도치 않게 인스턴스화 할 수 있다.**

**이러한 부분을 막기 위해 private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.**

→ 컴파일러가 기본 생성자를 만드는 경우는 명시된 생성자가 없을 때뿐이기 때문.

```java
public class UtilityClass {
	// 기본 생성자가 만들어지는 것을 막는다(인스턴스화 방지용)
	private UtilityClass() {
		throw new AssertionError();
	}

 ...
}
```

<br/>

- 명시적 생성자가 `private` 라 클래스 바깥에서는 접근 불가능
  - 생성자를 호출하지 못하게 한 이유를 직관적으로 알 수 있게 적절한 주석을 달자.
- 상속이 불가능하게 하는 효과도 있다.

> 해당 파트의 정적 팩터리 메서드는 디자인 패턴에서의 팩터리 메서드와 다르다. 디자인 패턴중엔 이와 일치하는 패턴은 없다.

클래스는 클라이언트에 public 생성자 (or 생성자) 대신 정적팩터리 메서드를 제공할 수 있다.
