---
layout: post
title: "[자바의 정석] 6.객체지향 프로그래밍 I 정리"
subtitle: "java"
date: 2021-11-07 22:24:00
categories: devlog
tags: java 글또
---

![image-20210815114036054](https://tva1.sinaimg.cn/large/008i3skNgy1gth9xn4muuj61e80l40u802.jpg)

# 6. 객체지향 프로그래밍 I

# 1. 객체지향언어

객체지향 이론의 기본 개념은 **실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다** 라는 것이다.

실제 사물의 **속성과 기능을 분석**한 다음, **데이터와 함수로 정의함**으로써 실제 세계를 컴퓨터 속에 옮겨 놓은 것과 같은 가상 세계를 구현한다.

## 특징


>💡 **재사용성**과 **유지보수** 그리고 **중복된 코드의 제거**의 3가지 관점에서 보는것이 좋다.


1. 코드의 재사용성이 높다.
2. 코드의 관리가 용이하다.
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.

---

# 2. 클래스와 객체

## 클래스

- 정의
  - 객체를 정의해 놓은 것
- 용도
  - 객체를 생성하기 위해 사용

## 객체

- 정의
  - 실제로 존재하는 사물 또는 개념
- 용도
  - 객체가 가지고 있는 기능과 속성에 따라 다름

### 객체와 인스턴스

- **클래스 → 객체**
  - *클래스의 인스턴스화*
  - 어떤 클래스로부터 만들어진 객체를 그 클래스의 **인스턴스**라고 한다.

### 구성요소

**객체**는 **속성과 기능** 두 종류의 구성 요소로 이루어져 있다. 다수의 속성과 다수의 기능을 갖는다.

- **속성(property)**
  - 멤버변수(member variable)
  - 특성(attribute)
  - 필드(field)
  - 상태(state)
- **기능(function)**
  - 메서드(method)
  - 함수(function)
  - 행위(behavior)

---

### 객체의 예제

![Untitled](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wpy21mfj30ju0enjse.jpg)

### 단계별로 살펴보기

![Untitled 1](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wrijc21j30k70fa3zo.jpg)

![Untitled 2](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wpyp843j30kd0wcwh2.jpg)

![Untitled 3](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wq5kqtdj30jx03xwev.jpg)

***Tv라는 객체를 두개 만들면 어떻게 될까?***

```java
Tv t1 = new Tv();
Tv t2 = new Tv();
```

![Untitled 4](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wq2bbtqj30j3074mxg.jpg)

위 그림과 같이 각 **t1**, **t2**는 각각 다른 객체로 볼 수 있다.

***t2에 t1을 대입한다면?***

```java
t2 = t1;
```

![Untitled 5](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wq1g56cj30ip0703yt.jpg)

**t2는 t1의 주소를 가르키게 된다.** 기존 t2의 자료는 차후 java의 가비지 컬렉터에 의해 제거되게 된다.

이 개념을 더욱 깊게 알아가기 위해선 [Deep Copy와 Shallow Copy](https://jackjeong.tistory.com/100)를 참고하자.

---

## 객체 배열

객체배열 내에는 객체의 주소가 저장된다. **즉 객체 배열은 참조변수들을 하나로 묶은 참조변수 배열이다.**

### Tv 객체 배열

```java
Tv[] tvArr = { new Tv(), new Tv(), new Tv() };
```

Array 타입에 클래스를 넣는다는 부분이 실무에서는 거의 사용하지 않아 생소한 문법이라, 책을 보면서 다시금 살짝 놀랐다.

---

## 클래스의 다른 정의

프로그래밍 언어에서 데이터 처리를 위한 저장형태의 발전과정은 다음과 같다.

![Untitled 6](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wxcavlnj30ke0653yn.jpg)

- 비 객체 지향적 코드와 객체 지향적 코드를 비교하면, 분리를 통해 보기 좋은 코드가 됨을 알 수있다.

![Untitled 7](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wpw8b4wj30hq07cwf4.jpg)

- **제어자를 이용**하여(private) 변수의 값을 직접 변경하지 못하도록 하고 메서드를 통해 값을 변경하도록 작성하면 **값의 유효성을 조건문으로 점검한 다음에 유효한 값일 경우에만 변경하도록 할 수 있다.**

---

# 3. 변수와 메서드

변수의 종류를 결정 짓는 중요한 요소는 **변수의 선언된 위치**이므로 **변수의 종류를 파악하기 위해선 변수가 어느 영역에 선언 되었는지를 확인하는 것이 중요**하다.

![Untitled 8](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wq0eyvqj30jm0d5jse.jpg)

---

## 변수

1. **인스턴스 변수**
   - 클래스 영역에 선언
   - 클래스의 인스턴스를 생성할 때 만들어 진다.
   - 인스턴스는 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다.
2. **클래스 변수**
   - **static**을 붙여서 선언한다.
   - 모든 인스턴스가 공통된 저장공간(변수)을 공유한다.
   - **클래스가 매모리에 로딩될때 생성되어 프로그램이 종료될 때 까지 유지**되며, **public**을 앞에 붙이면 **전역변수**의 성격을 갖는다.
   - 클래스 변수를 사용할 땐 **클래스이름.클래스변수**의 형태로 사용할 것
     - **(ex)** Card.width
     - 참조변수를 통해 사용(c1.width) 할 수 있지만 클래스 변수를 인스턴스 변수로 오해하기 쉽기 때문.
3. **지역 변수**
   - 메서드 내에 선언
   - 본인이 속한 Scope({}) 내에서만 사용 가능

---

## 메서드

**특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것.**

### 특징

- 높은 재사용성
  - 한번 만들어 놓은 메서드는 몇번이고 호출할 수 있다.
- 중복된 코드의 제거
  - 동일 로직을 구현할 때 메서드를 호출하는 한 문장으로 대체할 수 있다.
- 프로그램의 구조화
  - 규모가 큰 프로젝트 진행 시 문장들을 작업단위로 나눠 여러개의 메서드에 담아 구조를 단순화 시킬 수 있다.

### 예시

![Untitled 9](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wq951mdj30bv05mjrj.jpg)

### 선언과 구현

메서드는 크게 **선언부(header)**와 **구현부(body)**로 이루어져 있다.

![Untitled 10](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wpzhoklj30h6058dfx.jpg)

### 메서드의 구조

![Untitled 11](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wq7w1hlj30hx06r74i.jpg)

- 선언부

  - ***메서드의 이름***
    - 메서드의 기능을 쉽게 알 수 있도록 **함축적**이면서도 **의미있는 이름**을 지어야 한다.
  - ***반환타입***
    - **결과값의 반환타입**을 적는다. **반환값이 없는 경우 void**를 적는다.

- 구현부

  - ***return문***
    - **반환 타입과 일치**하거나 **자동 형변환이 가능한 값**을 적어준다.
    - 메서드에서 **단 하나의 값만 반환 가능**하다.
  - ***지역변수***
    - 메서드 내에 선언된 변수들은 그 **메서드 내에서만 사용 가능**하다.

  ### 메서드의 호출

  **메서드를 호출해야만 구현부({})의 문장들이 수행**된다.

  ```java
  print99danAll(); //메서드 호출
  int result = add(3, 5) //메서드를 호출하고 결과를 result에 저장
  ```

  - 인자
    - 메서드의 괄호() 안에 지정해준 값들을 인자 또는 인수라고 한다.
    - 인자의 타입, 개수와 순서는 호출된 메서드에 선언된 매개변수와 일치해야 한다.

### 메서드의 실행흐름

같은 클래스 내의 메서드끼리는 서로 호출이 가능하지만, **static 메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없다.**

메서드 실행중 다른 메서드가 호출되면 지금까지 실행중이던 메서드는 실행을 잠시 멈추고 호출된 메서드의 문장들이 실행된다.

![Untitled 12](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wq6mas5j30jm0az753.jpg)

### Return 문

**현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아간다.**

1. 반환값이 있는 경우, **return문이 없으면 컴파일 에러가 발생**한다.
2. 리턴 타입이 다를 경우 

---

### JVM의 메모리 구조

![Untitled 13](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wpv73h8j30g30glt9f.jpg)

- ***메서드 영역***
  - 프로그램 실행 중 어떤 클래스가 사용되면 JVM은 **해당 클래스의 클래스파일(*.class)을 읽어 분석하여 클래스 데이터를 이곳에 저장**.
  - **클래스 변수는 이 영역에 생성**됨.
- ***힙***
  - **인스턴스가 생성**되는 공간.
  - **인스턴스 변수들이 이 영역에 생성**됨.
- ***콜스택***
  - 메서드의 작업에 필요한 **메모리공간을 제공**.
  - 메서드가 작업을 수행하는 동안 **지역변수들과 연산의 중간결과 등을 저장하는데 사용**됨. 메서드가 작업을 마치면 할당된 메모리 공간은 비워진다.

---

### 기본형 매개변수와 참조형 매개변수

- ***기본형 매개변수***
  - 값 복사시 기본형 값이 복사된다.
  - 변수의 값을 읽기만 할 수 있다. (read only)
- ***참조형 매개변수***
  - 값 복사시 인스턴스의 주소가 복사된다.
  - 변수의 값을 읽고 변경할 수 있다.(read & write)

---

### 재귀호출

**메서드 내부에서 메서드 자신을 다시 호출하는 것을 재귀호출**이라고 하고 **재귀호출을 하는 메서드를 재귀 메서드**라고 한다.

무한 재귀호출문이 되지 않도록 조건을 걸어 빠져나올 수 있게 한다. 

![Untitled 14](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wqa9hdzj30jw04wmx9.jpg)

**반복 작업을 처리시 먼저 반복문으로 작성해보고 안된다면 재귀호출로 간단히 할 수 없는지 고민**해야한다.

왜냐면 재귀호출은 비효율적으로 재귀 호출 비용보다 재귀 호출의 간결함이 주는 이득이 큰 경우에만 사용해야 한다.

### 예시 (팩토리얼 함수 구현)

![Untitled 15](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wqb9108j30a803u747.jpg)

- 혹시나 0을 넣게되면 무한반복이 되면서 콜스택에 계속 쌓여 메모리를 넘기게 되는 **스택오버플로우 에러가 발생**한다.

메서드를 작성할 때 어떤 값이 들어와도 에러없이 처리되는 견고한 코드를 작성해야한다. **매개변수의 유효성 검사는 중요**하다.

---

## 클래스 메서드와 인스턴스 메서드

**메서드 앞에 static**이 붙어있으면 **클래스 메서드**이고, 붙어있지 않으면 인스턴스 메서드이다.

- 클래스를 설계할 때, **멤버 변수중 모든 인스턴스에 공통으로 사용하는 것에 static**을 붙인다.
- **static 변수는 인스턴스를 생성하지 않아도 사용**할 수 있다.
- **static 메서드는 인스턴스 변수를 사용할 수 없다.**
  - 이미 메모리 상에 클래스가 인스턴스보다 적재되기 때문에 아직 존재하지 않는 인스턴스 변수에 접근이 불가능하다.
- 메서드 내에서 **인스턴스 변수를 사용하지 않는다면 static을 붙이는 것을 고려**한다.

![Untitled 16](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wthbq0zj30jp0kudhn.jpg)

---

# 오버로딩

## 오버로딩이란?

한 클래스 내에 **동일한 메서드 이름**이 있더라도 **매개변수의 개수 또는 타입이 다르면 같은 이름을 사용**하여 메서드를 정의하는 것이다.

### 조건

- 메서드 이름이 같아야 한다.
- 매개변수의 개수 또는 타입이 달라야 한다.

### 예시

![Untitled 17](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wqau9wxj30770783yo.jpg)

### 장점

- 근본적으로 같은 기능을 하지만 **다른 타입을 핸들링 해야할 경우 동일한 이름으로 선언**할 수 있어 편하다.
- **메서드의 이름을 절약**할 수 있다.

## 가변인자와 오버로딩

> 💡 **{타입}... 변수명**으로 정의한다.

- **가변인자는 항상 마지막 매개변수**여야 한다.
- **내부적으로 배열을 사용**하기 때문에 **메서드를 호출할 때마다 배열이 새로 생성**된다. 필요한 경우에만 가변 인자를 사용하자.
- **가변인자**를 사용한 메서드는 **오버로딩**시 구별하지 못하는 경우가 생겨 **최대한 지양**한다.

### 예시

```java
public PrintStrema printf(String format, Object... args) { ... }
```

![Untitled 18](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wq3auwbj30js0893z7.jpg)

---

# 생성자

## 생성자란?

인스턴스가 생성될 때 호출되는 **인스턴스 초기화 메서드**이다.

- 생성자의 이름은 **클래스의 이름과 같아야** 한다.
- 생성자는 **리턴값이 없다.**
- 생성자도 **오버로딩이 가능**하다.
- 생성자를 **정의**하지 않으면 **컴파일러**가 **기본 생성자**를 만들어 준다.
  - 혹시나 **생성자를 하나라도 만들었다면 기본 생성자는 생성 되지 않으니** 참고.

## 예시

![Untitled 19](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wq45utsj30g50asmxf.jpg)

```java
Card c = new Card();
```

1. 연산자 **new**에 의해서 **힙 메모리에 Card클래스의 인스턴스가 생성**된다.
2. 생성자 **Card()가 호출**되어 수행된다.
3. 연산자 **new**의 결과로, 생성된 **Card 인스턴스의 주소가 반환**되어 참조변수에 저장된다.

**연산자 *new*가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다.**

![Untitled 20](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wu6hn81j30i303ht8p.jpg)

인스턴스를 생성한 다음 인스턴스변수의 값을 변경하는 것보다 **매개변수를 갖는 생성자를 사용하는 것이 더 직관적**인 코드를 만들게 된다.

## this(), this

## this

**인스턴스 자신을 가리키는 참조 변수**, 인스턴스의 주소가 저장되어 있다.

## this()

**인스턴스 자신의 생성자**를 가리킨다. 같은 클래스의 다른 생성자를 호출할 때 사용한다.

**생성자 간에도 서로 호출이 가능**하다. 단 아래와 같은 **두 조건**이 있다.

- 생성자의 이름으로 **클래스이름 대신 this를 사용**한다.
- 한 생성자에서 다른 생성자를 호출할 때는 **반드시 첫줄에서만 호출이 가능**하다.

### 잘못된 예

![Untitled 21](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wpxbg5lj30iu03x0st.jpg)

### 좋은 예

![Untitled 22](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wq72lqyj30hf07p0t0.jpg)

---

# 변수의 초기화

**변수를 선언하고 처음으로 값을 저장하는 것**을 변수의 초기화 라고 한다.

가능하면 **선언과 동시에 적절한 값으로 초기화** 하는것이 바람직하다.

**멤버변수**는 **초기화를 하지 않아도 자동으로 기본값으로 초기화**가 되지만, **지역변수**는 **사용하기 전에 반드시 초기화** 해야한다.

![Untitled 23](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wuld264j30f9065dfw.jpg)

## 멤버변수의 초기화 방법

1. 명시적 초기화
2. 생성자
3. 초기화 블럭

### 명시적 초기화

변수의 선언과 동시에 초기화 하는 것

### 초기화 블럭

- ***인스턴스 초기화 블럭***
  - 클래스 내에 **스코프({})** 를 만들고 그 안에 코드를 작성한다.
  - 주로 생성자를 이용
- ***클래스 초기화 블럭***
  - 인스턴스 초기화 블럭 앞에 **static**을 덧붙이면 된다.
  - 모든 생성자에서 공통으로 수행되어야 하는 코드를 넣음

## 초기화 시점

- 클래스 변수
  - 클래스가 처음 로딩될 때 단 한번 초기화 된다.
  - 기본값 → 명시적 초기화 → 클래스 초기화 블럭
- 인스턴스 변수
  - 인스턴스가 생성될 때마다 각 인스턴스 별로 초기화가 이루어진다.
  - 기본값 → 명시적 초기화 → 인스턴스 초기화 블럭 → 생성자

![Untitled 24](https://tva1.sinaimg.cn/large/008i3skNgy1gw6wq4lyrkj30h20860sw.jpg)
---

#### 출처

[자바의 정석](http://www.yes24.com/Product/Goods/24259565)